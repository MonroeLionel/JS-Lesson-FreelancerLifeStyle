// методы reduce\reduceRight
/*
итак мы выяснили что если нам нужно перебрать
массив мы можем использовать forEach, for или for..of
если нам нужно перебрать массив и вернуть 
данные для каждого элементы мы используем map

методы arr.reduce и arr.reduceRight похожи на эти методы
но они немного сложнее и используются для вычесления
какого нибудь единого значения на основе все массива
*/

//синтаксис
/*

let value = arr.reduce(function (previousValue, item, index, array) {
  //...
}, [initial]);

*/

/*
к привычным нам аргументам item,index,array 
добавляется previousValue

previousValue-результат предыдущего вызова этой функции равен initial при первом вызове (если передан initial)
initial-начальное значение 
item- очередной элемент массива
index- его индек
array-сам массив

функция применяется по очереди ко все элементам
массива и "переносит" свой результат на следующий вызов
*/

let arrOne = [1, 2, 3, 4, 5,];
let reduceValueOne = arrOne.reduce(function (previousValue, item, index, array) {
  return item + previousValue;
}, 0); //начальное значение для previousValuem указываем 0 можно поставить любое другое
console.log(reduceValueOne);

/*
шаг 1
previousValuem = 0
item = 1
их сумма = 1

шаг 2
previousValuem = 1
item = 2
их сумма = 3

шаг 3
previousValuem = 3
item = 3
их сумма = 6

шаг 4
previousValuem = 6
item = 4
их сумма = 10

шаг 5
previousValuem = 10
item = 5
их сумма = 15

*/

let arrTwo = [`ноль`, `один`, `два`, `три`, `четыре`, `пять`,];
/*
елси не указывать начальное значение то оно будет авно
первому элементу массива (previousValue=`ноль`)
а работа метода начнется со второго элемента (item=`один`)
*/

let reduceValueTwo = arrTwo.reduce(function (previousValue, item, index, array) {
  console.log(previousValue);
  console.log(item);
  return `${item}, ${previousValue}`;
}); //initial не задан

console.log(`тест: ${reduceValueTwo}`);

//метод arr.reduceRight работает аалогично
//но проходит по массиву справа налево

/*
но то что действительно делает массивы особенными это их вутренее
представлени.Движок JS старается хранить элементы 
массива в непрерывной области памяти оди за другим
существуют и другие способы оптимизации благодаря которым
массивы работают очень быстро

но все они утратят эффективность если мы перестанем работать
с массивлм как с "упорядоченной колекцией данных" и начнем
использовать его как обычнй объект

вариаты неправильного применения массива:
1 добавление нечислового совйства например как объекту
2 создание "дыр" например объявление добавление arr[0] затем arr[10000] (между ними ничего нету)
3 зполнение массива в обратном порядке например
arr[1000] arr[999]

*/